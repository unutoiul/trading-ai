"""Generate Pine Script trading strategies from pattern analysis results."""

import os
from datetime import datetime

def generate_pine_script(pattern_stats, ml_results=None, **kwargs):
    """
    Generate a TradingView Pine Script strategy from analysis results.
    
    Args:
        pattern_stats: Dict of pattern analysis results
        ml_results: Optional machine learning results
        kwargs: Additional parameters for customizing the strategy
        
    Returns:
        str: The generated Pine Script
    """
    # Extract parameters with defaults
    strategy_type = kwargs.get('strategy_type', 'momentum')
    risk_per_trade = kwargs.get('risk_per_trade', 1.0)
    use_stop_loss = kwargs.get('use_stop_loss', True)
    stop_loss_percent = kwargs.get('stop_loss_percent', 5.0)
    use_take_profit = kwargs.get('use_take_profit', True)
    take_profit_percent = kwargs.get('take_profit_percent', 10.0)
    
    # Identify the most significant patterns
    top_patterns = _extract_top_patterns(pattern_stats, ml_results)
    
    # Generate script header
    script = []
    script.append(f"""
// @version=5
// Generated by Trading AI on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
// Strategy Type: {strategy_type}
// Risk per Trade: {risk_per_trade}%
// Stop Loss: {'Enabled' if use_stop_loss else 'Disabled'} ({stop_loss_percent}%)
// Take Profit: {'Enabled' if use_take_profit else 'Disabled'} ({take_profit_percent}%)

strategy("BTC-Altcoin {strategy_type.capitalize()} Strategy", overlay=true, margin_long=100, margin_short=100)

// ===== Strategy Settings =====
// User-configurable settings
riskPercentage = input.float({risk_per_trade}, "Risk per trade (%)", minval=0.1, maxval=10.0, step=0.1)
maxPositions = input.int(2, "Maximum concurrent positions", minval=1, maxval=10)
useStopLoss = input.bool({str(use_stop_loss).lower()}, "Use Stop Loss")
stopLossPercent = input.float({stop_loss_percent}, "Stop Loss (%)", minval=1.0, maxval=20.0)
useTakeProfit = input.bool({str(use_take_profit).lower()}, "Use Take Profit")
takeProfitPercent = input.float({take_profit_percent}, "Take Profit (%)", minval=1.0, maxval=50.0)

// ===== Get BTC Data =====
// We need to get BTC data for our patterns
btcSymbol = input.symbol("BTCUSDT", "BTC Symbol")
btcTimeframe = input.timeframe("15", "BTC Timeframe")
""")
    
    # Add BTC data fetching section
    script.append("""
// Get BTC data
[btcOpen, btcHigh, btcLow, btcClose] = request.security(btcSymbol, btcTimeframe, [open, high, low, close])
btcVol = request.security(btcSymbol, btcTimeframe, volume)

// Calculate BTC returns and metrics
btcReturns = (btcClose - btcClose[1]) / btcClose[1] * 100
btcVolumeRatio = btcVol / ta.sma(btcVol, 20)
btcRSI = ta.rsi(btcClose, 14)
btcMacd = ta.macd(btcClose, 12, 26, 9)
btcMacdLine = btcMacd
btcSignalLine = ta.sma(btcMacd, 9)
btcMacdHistogram = btcMacdLine - btcSignalLine
""")
    
    # Add pattern detection functions
    script.append("""
// ===== Pattern Detection Functions =====
// BTC Momentum Patterns

// Detect strong bullish momentum
strongBullishMomentum() =>
    btcReturns > 1.0 and btcReturns[1] > 0.5 and btcClose > btcOpen and btcVol > ta.sma(btcVol, 20)

// Detect bearish momentum
bearishMomentum() =>
    btcReturns < -1.0 and btcClose < btcOpen and btcVol > ta.sma(btcVol, 20)

// Detect consolidation phase
consolidation() =>
    math.abs(btcReturns) < 0.5 and math.abs(btcReturns[1]) < 0.5 and btcVol < ta.sma(btcVol, 20)

// Detect breakout pattern
breakout() =>
    btcReturns > 1.5 and btcReturns[1] < 0.2 and btcClose > btcClose[1] and btcVol > ta.sma(btcVol, 20) * 1.5

// Detect breakdown pattern
breakdown() =>
    btcReturns < -1.5 and btcReturns[1] > -0.2 and btcClose < btcClose[1] and btcVol > ta.sma(btcVol, 20) * 1.5

// Detect recovery pattern
recovery() =>
    btcReturns > 0.8 and btcReturns[1] < -0.8 and btcClose > btcOpen and btcVol > ta.sma(btcVol, 20)
""")
    
    # Add strategy type specific indicators
    if strategy_type == 'momentum':
        script.append("""
// ==== Momentum Strategy Indicators ====
// For momentum strategies, we focus on rapid price changes and volume
btcMomentum = ta.mom(btcClose, 10)
btcVolumeSurge = btcVol > ta.sma(btcVol, 20) * 1.5
""")
    elif strategy_type == 'pattern':
        script.append("""
// ==== Pattern Recognition Indicators ====
// For pattern recognition, we use multiple indicators
btcMacdCrossOver = ta.crossover(btcMacdLine, btcSignalLine)
btcMacdCrossUnder = ta.crossunder(btcMacdLine, btcSignalLine)
btcGoldenCross = ta.crossover(ta.sma(btcClose, 50), ta.sma(btcClose, 200))
btcDeathCross = ta.crossunder(ta.sma(btcClose, 50), ta.sma(btcClose, 200))
""")
    elif strategy_type == 'ml':
        script.append("""
// ==== ML-Based Strategy Indicators ====
// For ML-based strategies, we use the indicators from our model
// The most important features based on XGBoost analysis
btcVolumeChange = (btcVol - btcVol[1]) / btcVol[1] * 100
btcPriceVolatility = ta.stdev(btcReturns, 14)
btcPriceTrend = ta.ema(btcClose, 8) - ta.ema(btcClose, 21)
""")
    
    # Build entry and exit conditions based on top patterns
    entry_conditions = []
    exit_conditions = []
    
    for pattern_name, lag, _ in top_patterns[:3]:  # Use top 3 patterns
        pattern_var = f"var_{pattern_name}"
        
        # Pattern detection variable
        script.append(f"\n// Pattern: {pattern_name}")
        
        if "bullish" in pattern_name.lower():
            script.append(f"{pattern_var} = strongBullishMomentum()")
            entry_conditions.append(f"{pattern_var}[{lag}]")
        elif "bearish" in pattern_name.lower():
            script.append(f"{pattern_var} = bearishMomentum()")
            # For bearish BTC patterns that might have positive effect on alts
            entry_conditions.append(f"{pattern_var}[{lag}]")
        elif "breakout" in pattern_name.lower():
            script.append(f"{pattern_var} = breakout()")
            entry_conditions.append(f"{pattern_var}[{lag}]")
        elif "breakdown" in pattern_name.lower():
            script.append(f"{pattern_var} = breakdown()")
            entry_conditions.append(f"{pattern_var}[{lag}]")
        elif "recovery" in pattern_name.lower() or "bounce" in pattern_name.lower():
            script.append(f"{pattern_var} = recovery()")
            entry_conditions.append(f"{pattern_var}[{lag}]")
        elif "consolidation" in pattern_name.lower() or "ranging" in pattern_name.lower():
            script.append(f"{pattern_var} = consolidation()")
            entry_conditions.append(f"{pattern_var}[{lag}]")
        else:
            # Default for other patterns - use a general strong pattern
            script.append(f"{pattern_var} = strongBullishMomentum() or recovery()")
            entry_conditions.append(f"{pattern_var}[{lag}]")
    
    # Add strategy-specific conditions
    if strategy_type == 'momentum':
        entry_conditions.append("btcMomentum > 0")
        entry_conditions.append("btcVolumeSurge")
        exit_conditions.append("btcMomentum < 0")
    elif strategy_type == 'pattern':
        entry_conditions.append("btcMacdCrossOver")
        exit_conditions.append("btcMacdCrossUnder")
    elif strategy_type == 'ml':
        entry_conditions.append("btcPriceTrend > 0")
        entry_conditions.append("btcVolumeChange > 5")
        exit_conditions.append("btcPriceTrend < 0")
    
    # Default exit conditions
    exit_conditions.append("bearishMomentum()")
    
    # Combine conditions
    entry_logic = " or ".join(entry_conditions)
    exit_logic = " or ".join(exit_conditions)
    
    # Add entry/exit logic
    script.append(f"""
// ===== Entry and Exit Conditions =====
// Entry logic
entryCondition = {entry_logic}

// Exit logic
exitCondition = {exit_logic}

// ===== Money Management =====
// Calculate position size based on risk percentage
price = close
riskAmount = strategy.equity * (riskPercentage / 100)
stopLossPrice = useStopLoss ? price * (1 - stopLossPercent / 100) : na
takeProfitPrice = useTakeProfit ? price * (1 + takeProfitPercent / 100) : na
positionSize = useStopLoss ? riskAmount / (price - stopLossPrice) : strategy.equity / price

// ===== Strategy Execution =====
// Entry rules - only enter if we're not already in a position
if (entryCondition and strategy.position_size == 0 and strategy.opentrades < maxPositions)
    strategy.entry("Long", strategy.long, qty=positionSize)
    
    // Set stop loss and take profit
    if (useStopLoss)
        strategy.exit("SL", "Long", stop=stopLossPrice)
    
    if (useTakeProfit)
        strategy.exit("TP", "Long", limit=takeProfitPrice)

// Exit rules
if (exitCondition and strategy.position_size > 0)
    strategy.close("Long")

// Plot indicators
plotshape(series=entryCondition, title="Entry Signal", location=location.belowbar, color=color.green, style=shape.triangleup, size=size.small)
plotshape(series=exitCondition, title="Exit Signal", location=location.abovebar, color=color.red, style=shape.triangledown, size=size.small)

// === Strategy Commentary ===
// This strategy trades altcoins based on BTC's movement patterns.
// It identifies key BTC patterns that historically affect the altcoin.
// Entry signals occur when BTC shows patterns that precede altcoin rises.
// Risk management includes position sizing and optional stop-loss/take-profit.
""")
    
    return '\n'.join(script)

def _extract_top_patterns(pattern_stats, ml_results=None):
    """Extract the most significant patterns from the analysis results."""
    top_patterns = []
    
    # First try to extract from ML results if available
    if ml_results and 'feature_importance' in ml_results:
        feature_importances = ml_results['feature_importance']
        for feature, importance in feature_importances:
            if 'pattern' in feature.lower() and 'lag' in feature.lower():
                try:
                    # Extract pattern name and lag
                    parts = feature.split('_lag')
                    pattern_name = parts[0].replace('btc_pattern_', '')
                    lag = int(parts[1]) if len(parts > 1) else 1
                    
                    top_patterns.append((pattern_name, lag, importance))
                except:
                    pass
    
    # If we didn't get enough patterns from ML, try pattern_stats
    if len(top_patterns) < 3 and pattern_stats:
        for pattern_key, lags in pattern_stats.items():
            if pattern_key.startswith('btc_pattern_'):
                try:
                    pattern_name = pattern_key.replace('btc_pattern_', '')
                    
                    # Find lag with highest absolute response
                    best_lag = 1
                    best_response = 0
                    for lag, data in lags.items():
                        if abs(data['mean_response']) > abs(best_response):
                            best_response = data['mean_response']
                            best_lag = int(lag)
                    
                    importance = abs(best_response)
                    top_patterns.append((pattern_name, best_lag, importance))
                except:
                    pass
    
    # If still not enough, add default patterns
    default_patterns = [
        ('strong_bullish', 1, 0.5),
        ('recovery', 1, 0.4),
        ('breakdown', 2, 0.3)
    ]
    
    for pattern in default_patterns:
        if len(top_patterns) < 3:
            if pattern[0] not in [p[0] for p in top_patterns]:
                top_patterns.append(pattern)
    
    # Sort by importance and return top patterns
    return sorted(top_patterns, key=lambda x: x[2], reverse=True)